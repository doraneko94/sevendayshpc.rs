/* automatically generated by rust-bindgen */

pub const FFI_CLOSURES : :: std :: os :: raw :: c_uint = 1 ; pub const FFI_TRAMPOLINE_SIZE : :: std :: os :: raw :: c_uint = 24 ; pub const FFI_NATIVE_RAW_API : :: std :: os :: raw :: c_uint = 0 ; pub const _LIBC_LIMITS_H_ : :: std :: os :: raw :: c_uint = 1 ; pub const _FEATURES_H : :: std :: os :: raw :: c_uint = 1 ; pub const __USE_ANSI : :: std :: os :: raw :: c_uint = 1 ; pub const _BSD_SOURCE : :: std :: os :: raw :: c_uint = 1 ; pub const _SVID_SOURCE : :: std :: os :: raw :: c_uint = 1 ; pub const __USE_ISOC11 : :: std :: os :: raw :: c_uint = 1 ; pub const __USE_ISOC99 : :: std :: os :: raw :: c_uint = 1 ; pub const __USE_ISOC95 : :: std :: os :: raw :: c_uint = 1 ; pub const _POSIX_SOURCE : :: std :: os :: raw :: c_uint = 1 ; pub const _POSIX_C_SOURCE : :: std :: os :: raw :: c_uint = 200809 ; pub const __USE_POSIX_IMPLICITLY : :: std :: os :: raw :: c_uint = 1 ; pub const __USE_POSIX : :: std :: os :: raw :: c_uint = 1 ; pub const __USE_POSIX2 : :: std :: os :: raw :: c_uint = 1 ; pub const __USE_POSIX199309 : :: std :: os :: raw :: c_uint = 1 ; pub const __USE_POSIX199506 : :: std :: os :: raw :: c_uint = 1 ; pub const __USE_XOPEN2K : :: std :: os :: raw :: c_uint = 1 ; pub const __USE_XOPEN2K8 : :: std :: os :: raw :: c_uint = 1 ; pub const _ATFILE_SOURCE : :: std :: os :: raw :: c_uint = 1 ; pub const __USE_MISC : :: std :: os :: raw :: c_uint = 1 ; pub const __USE_BSD : :: std :: os :: raw :: c_uint = 1 ; pub const __USE_SVID : :: std :: os :: raw :: c_uint = 1 ; pub const __USE_ATFILE : :: std :: os :: raw :: c_uint = 1 ; pub const __USE_FORTIFY_LEVEL : :: std :: os :: raw :: c_uint = 0 ; pub const _STDC_PREDEF_H : :: std :: os :: raw :: c_uint = 1 ; pub const __STDC_IEC_559__ : :: std :: os :: raw :: c_uint = 1 ; pub const __STDC_IEC_559_COMPLEX__ : :: std :: os :: raw :: c_uint = 1 ; pub const __STDC_ISO_10646__ : :: std :: os :: raw :: c_uint = 201103 ; pub const __STDC_NO_THREADS__ : :: std :: os :: raw :: c_uint = 1 ; pub const __GNU_LIBRARY__ : :: std :: os :: raw :: c_uint = 6 ; pub const __GLIBC__ : :: std :: os :: raw :: c_uint = 2 ; pub const __GLIBC_MINOR__ : :: std :: os :: raw :: c_uint = 17 ; pub const __GLIBC_HAVE_LONG_LONG : :: std :: os :: raw :: c_uint = 1 ; pub const _SYS_CDEFS_H : :: std :: os :: raw :: c_uint = 1 ; pub const __WORDSIZE : :: std :: os :: raw :: c_uint = 64 ; pub const __WORDSIZE_TIME64_COMPAT32 : :: std :: os :: raw :: c_uint = 1 ; pub const __SYSCALL_WORDSIZE : :: std :: os :: raw :: c_uint = 64 ; pub const MB_LEN_MAX : :: std :: os :: raw :: c_uint = 16 ; pub const _BITS_POSIX1_LIM_H : :: std :: os :: raw :: c_uint = 1 ; pub const _POSIX_AIO_LISTIO_MAX : :: std :: os :: raw :: c_uint = 2 ; pub const _POSIX_AIO_MAX : :: std :: os :: raw :: c_uint = 1 ; pub const _POSIX_ARG_MAX : :: std :: os :: raw :: c_uint = 4096 ; pub const _POSIX_CHILD_MAX : :: std :: os :: raw :: c_uint = 25 ; pub const _POSIX_DELAYTIMER_MAX : :: std :: os :: raw :: c_uint = 32 ; pub const _POSIX_HOST_NAME_MAX : :: std :: os :: raw :: c_uint = 255 ; pub const _POSIX_LINK_MAX : :: std :: os :: raw :: c_uint = 8 ; pub const _POSIX_LOGIN_NAME_MAX : :: std :: os :: raw :: c_uint = 9 ; pub const _POSIX_MAX_CANON : :: std :: os :: raw :: c_uint = 255 ; pub const _POSIX_MAX_INPUT : :: std :: os :: raw :: c_uint = 255 ; pub const _POSIX_MQ_OPEN_MAX : :: std :: os :: raw :: c_uint = 8 ; pub const _POSIX_MQ_PRIO_MAX : :: std :: os :: raw :: c_uint = 32 ; pub const _POSIX_NAME_MAX : :: std :: os :: raw :: c_uint = 14 ; pub const _POSIX_NGROUPS_MAX : :: std :: os :: raw :: c_uint = 8 ; pub const _POSIX_OPEN_MAX : :: std :: os :: raw :: c_uint = 20 ; pub const _POSIX_PATH_MAX : :: std :: os :: raw :: c_uint = 256 ; pub const _POSIX_PIPE_BUF : :: std :: os :: raw :: c_uint = 512 ; pub const _POSIX_RE_DUP_MAX : :: std :: os :: raw :: c_uint = 255 ; pub const _POSIX_RTSIG_MAX : :: std :: os :: raw :: c_uint = 8 ; pub const _POSIX_SEM_NSEMS_MAX : :: std :: os :: raw :: c_uint = 256 ; pub const _POSIX_SEM_VALUE_MAX : :: std :: os :: raw :: c_uint = 32767 ; pub const _POSIX_SIGQUEUE_MAX : :: std :: os :: raw :: c_uint = 32 ; pub const _POSIX_SSIZE_MAX : :: std :: os :: raw :: c_uint = 32767 ; pub const _POSIX_STREAM_MAX : :: std :: os :: raw :: c_uint = 8 ; pub const _POSIX_SYMLINK_MAX : :: std :: os :: raw :: c_uint = 255 ; pub const _POSIX_SYMLOOP_MAX : :: std :: os :: raw :: c_uint = 8 ; pub const _POSIX_TIMER_MAX : :: std :: os :: raw :: c_uint = 32 ; pub const _POSIX_TTY_NAME_MAX : :: std :: os :: raw :: c_uint = 9 ; pub const _POSIX_TZNAME_MAX : :: std :: os :: raw :: c_uint = 6 ; pub const _POSIX_CLOCKRES_MIN : :: std :: os :: raw :: c_uint = 20000000 ; pub const NR_OPEN : :: std :: os :: raw :: c_uint = 1024 ; pub const NGROUPS_MAX : :: std :: os :: raw :: c_uint = 65536 ; pub const ARG_MAX : :: std :: os :: raw :: c_uint = 131072 ; pub const LINK_MAX : :: std :: os :: raw :: c_uint = 127 ; pub const MAX_CANON : :: std :: os :: raw :: c_uint = 255 ; pub const MAX_INPUT : :: std :: os :: raw :: c_uint = 255 ; pub const NAME_MAX : :: std :: os :: raw :: c_uint = 255 ; pub const PATH_MAX : :: std :: os :: raw :: c_uint = 4096 ; pub const PIPE_BUF : :: std :: os :: raw :: c_uint = 4096 ; pub const XATTR_NAME_MAX : :: std :: os :: raw :: c_uint = 255 ; pub const XATTR_SIZE_MAX : :: std :: os :: raw :: c_uint = 65536 ; pub const XATTR_LIST_MAX : :: std :: os :: raw :: c_uint = 65536 ; pub const RTSIG_MAX : :: std :: os :: raw :: c_uint = 32 ; pub const _POSIX_THREAD_KEYS_MAX : :: std :: os :: raw :: c_uint = 128 ; pub const PTHREAD_KEYS_MAX : :: std :: os :: raw :: c_uint = 1024 ; pub const _POSIX_THREAD_DESTRUCTOR_ITERATIONS : :: std :: os :: raw :: c_uint = 4 ; pub const PTHREAD_DESTRUCTOR_ITERATIONS : :: std :: os :: raw :: c_uint = 4 ; pub const _POSIX_THREAD_THREADS_MAX : :: std :: os :: raw :: c_uint = 64 ; pub const AIO_PRIO_DELTA_MAX : :: std :: os :: raw :: c_uint = 20 ; pub const PTHREAD_STACK_MIN : :: std :: os :: raw :: c_uint = 16384 ; pub const DELAYTIMER_MAX : :: std :: os :: raw :: c_uint = 2147483647 ; pub const TTY_NAME_MAX : :: std :: os :: raw :: c_uint = 32 ; pub const LOGIN_NAME_MAX : :: std :: os :: raw :: c_uint = 256 ; pub const HOST_NAME_MAX : :: std :: os :: raw :: c_uint = 64 ; pub const MQ_PRIO_MAX : :: std :: os :: raw :: c_uint = 32768 ; pub const SEM_VALUE_MAX : :: std :: os :: raw :: c_uint = 2147483647 ; pub const _BITS_POSIX2_LIM_H : :: std :: os :: raw :: c_uint = 1 ; pub const _POSIX2_BC_BASE_MAX : :: std :: os :: raw :: c_uint = 99 ; pub const _POSIX2_BC_DIM_MAX : :: std :: os :: raw :: c_uint = 2048 ; pub const _POSIX2_BC_SCALE_MAX : :: std :: os :: raw :: c_uint = 99 ; pub const _POSIX2_BC_STRING_MAX : :: std :: os :: raw :: c_uint = 1000 ; pub const _POSIX2_COLL_WEIGHTS_MAX : :: std :: os :: raw :: c_uint = 2 ; pub const _POSIX2_EXPR_NEST_MAX : :: std :: os :: raw :: c_uint = 32 ; pub const _POSIX2_LINE_MAX : :: std :: os :: raw :: c_uint = 2048 ; pub const _POSIX2_RE_DUP_MAX : :: std :: os :: raw :: c_uint = 255 ; pub const _POSIX2_CHARCLASS_NAME_MAX : :: std :: os :: raw :: c_uint = 14 ; pub const BC_BASE_MAX : :: std :: os :: raw :: c_uint = 99 ; pub const BC_DIM_MAX : :: std :: os :: raw :: c_uint = 2048 ; pub const BC_SCALE_MAX : :: std :: os :: raw :: c_uint = 99 ; pub const BC_STRING_MAX : :: std :: os :: raw :: c_uint = 1000 ; pub const COLL_WEIGHTS_MAX : :: std :: os :: raw :: c_uint = 255 ; pub const EXPR_NEST_MAX : :: std :: os :: raw :: c_uint = 32 ; pub const LINE_MAX : :: std :: os :: raw :: c_uint = 2048 ; pub const CHARCLASS_NAME_MAX : :: std :: os :: raw :: c_uint = 2048 ; pub const RE_DUP_MAX : :: std :: os :: raw :: c_uint = 32767 ; pub const FFI_64_BIT_MAX : :: std :: os :: raw :: c_ulonglong = 9223372036854775807 ; pub const FFI_SIZEOF_ARG : :: std :: os :: raw :: c_uint = 8 ; pub const FFI_SIZEOF_JAVA_RAW : :: std :: os :: raw :: c_uint = 8 ; pub const FFI_TYPE_VOID : :: std :: os :: raw :: c_uint = 0 ; pub const FFI_TYPE_INT : :: std :: os :: raw :: c_uint = 1 ; pub const FFI_TYPE_FLOAT : :: std :: os :: raw :: c_uint = 2 ; pub const FFI_TYPE_DOUBLE : :: std :: os :: raw :: c_uint = 3 ; pub const FFI_TYPE_LONGDOUBLE : :: std :: os :: raw :: c_uint = 4 ; pub const FFI_TYPE_UINT8 : :: std :: os :: raw :: c_uint = 5 ; pub const FFI_TYPE_SINT8 : :: std :: os :: raw :: c_uint = 6 ; pub const FFI_TYPE_UINT16 : :: std :: os :: raw :: c_uint = 7 ; pub const FFI_TYPE_SINT16 : :: std :: os :: raw :: c_uint = 8 ; pub const FFI_TYPE_UINT32 : :: std :: os :: raw :: c_uint = 9 ; pub const FFI_TYPE_SINT32 : :: std :: os :: raw :: c_uint = 10 ; pub const FFI_TYPE_UINT64 : :: std :: os :: raw :: c_uint = 11 ; pub const FFI_TYPE_SINT64 : :: std :: os :: raw :: c_uint = 12 ; pub const FFI_TYPE_STRUCT : :: std :: os :: raw :: c_uint = 13 ; pub const FFI_TYPE_POINTER : :: std :: os :: raw :: c_uint = 14 ; pub const FFI_TYPE_COMPLEX : :: std :: os :: raw :: c_uint = 15 ; pub const FFI_TYPE_LAST : :: std :: os :: raw :: c_uint = 15 ; pub type ffi_arg = :: std :: os :: raw :: c_ulong ; pub type ffi_sarg = :: std :: os :: raw :: c_long ; pub const ffi_abi_FFI_FIRST_ABI : ffi_abi = 0 ; pub const ffi_abi_FFI_SYSV : ffi_abi = 1 ; pub const ffi_abi_FFI_UNIX64 : ffi_abi = 2 ; pub const ffi_abi_FFI_THISCALL : ffi_abi = 3 ; pub const ffi_abi_FFI_FASTCALL : ffi_abi = 4 ; pub const ffi_abi_FFI_STDCALL : ffi_abi = 5 ; pub const ffi_abi_FFI_PASCAL : ffi_abi = 6 ; pub const ffi_abi_FFI_REGISTER : ffi_abi = 7 ; pub const ffi_abi_FFI_LAST_ABI : ffi_abi = 8 ; pub const ffi_abi_FFI_DEFAULT_ABI : ffi_abi = 2 ; pub type ffi_abi = :: std :: os :: raw :: c_uint ; pub type wchar_t = :: std :: os :: raw :: c_int ; # [ repr ( C ) ] # [ derive ( Debug , Copy , Clone ) ] pub struct _ffi_type { pub size : usize , pub alignment : :: std :: os :: raw :: c_ushort , pub type_ : :: std :: os :: raw :: c_ushort , pub elements : * mut * mut _ffi_type , } # [ test ] fn bindgen_test_layout__ffi_type ( ) { assert_eq ! ( :: std :: mem :: size_of :: < _ffi_type > ( ) , 24usize , concat ! ( "Size of: " , stringify ! ( _ffi_type ) ) ) ; assert_eq ! ( :: std :: mem :: align_of :: < _ffi_type > ( ) , 8usize , concat ! ( "Alignment of " , stringify ! ( _ffi_type ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const _ffi_type ) ) . size as * const _ as usize } , 0usize , concat ! ( "Alignment of field: " , stringify ! ( _ffi_type ) , "::" , stringify ! ( size ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const _ffi_type ) ) . alignment as * const _ as usize } , 8usize , concat ! ( "Alignment of field: " , stringify ! ( _ffi_type ) , "::" , stringify ! ( alignment ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const _ffi_type ) ) . type_ as * const _ as usize } , 10usize , concat ! ( "Alignment of field: " , stringify ! ( _ffi_type ) , "::" , stringify ! ( type_ ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const _ffi_type ) ) . elements as * const _ as usize } , 16usize , concat ! ( "Alignment of field: " , stringify ! ( _ffi_type ) , "::" , stringify ! ( elements ) ) ) ; } impl Default for _ffi_type { fn default ( ) -> Self { unsafe { :: std :: mem :: zeroed ( ) } } } pub type ffi_type = _ffi_type ; extern "C" {
 # [ link_name = "\u{1}ffi_type_void" ] 
 pub static mut  ffi_type_void  :  ffi_type ;
} extern "C" {
 # [ link_name = "\u{1}ffi_type_uint8" ] 
 pub static mut  ffi_type_uint8  :  ffi_type ;
} extern "C" {
 # [ link_name = "\u{1}ffi_type_sint8" ] 
 pub static mut  ffi_type_sint8  :  ffi_type ;
} extern "C" {
 # [ link_name = "\u{1}ffi_type_uint16" ] 
 pub static mut  ffi_type_uint16  :  ffi_type ;
} extern "C" {
 # [ link_name = "\u{1}ffi_type_sint16" ] 
 pub static mut  ffi_type_sint16  :  ffi_type ;
} extern "C" {
 # [ link_name = "\u{1}ffi_type_uint32" ] 
 pub static mut  ffi_type_uint32  :  ffi_type ;
} extern "C" {
 # [ link_name = "\u{1}ffi_type_sint32" ] 
 pub static mut  ffi_type_sint32  :  ffi_type ;
} extern "C" {
 # [ link_name = "\u{1}ffi_type_uint64" ] 
 pub static mut  ffi_type_uint64  :  ffi_type ;
} extern "C" {
 # [ link_name = "\u{1}ffi_type_sint64" ] 
 pub static mut  ffi_type_sint64  :  ffi_type ;
} extern "C" {
 # [ link_name = "\u{1}ffi_type_float" ] 
 pub static mut  ffi_type_float  :  ffi_type ;
} extern "C" {
 # [ link_name = "\u{1}ffi_type_double" ] 
 pub static mut  ffi_type_double  :  ffi_type ;
} extern "C" {
 # [ link_name = "\u{1}ffi_type_pointer" ] 
 pub static mut  ffi_type_pointer  :  ffi_type ;
} extern "C" {
 # [ link_name = "\u{1}ffi_type_longdouble" ] 
 pub static mut  ffi_type_longdouble  :  ffi_type ;
} extern "C" {
 # [ link_name = "\u{1}ffi_type_complex_float" ] 
 pub static mut  ffi_type_complex_float  :  ffi_type ;
} extern "C" {
 # [ link_name = "\u{1}ffi_type_complex_double" ] 
 pub static mut  ffi_type_complex_double  :  ffi_type ;
} extern "C" {
 # [ link_name = "\u{1}ffi_type_complex_longdouble" ] 
 pub static mut  ffi_type_complex_longdouble  :  ffi_type ;
} pub const ffi_status_FFI_OK : ffi_status = 0 ; pub const ffi_status_FFI_BAD_TYPEDEF : ffi_status = 1 ; pub const ffi_status_FFI_BAD_ABI : ffi_status = 2 ; pub type ffi_status = :: std :: os :: raw :: c_uint ; pub type FFI_TYPE = :: std :: os :: raw :: c_uint ; # [ repr ( C ) ] # [ derive ( Debug , Copy , Clone ) ] pub struct ffi_cif { pub abi : ffi_abi , pub nargs : :: std :: os :: raw :: c_uint , pub arg_types : * mut * mut ffi_type , pub rtype : * mut ffi_type , pub bytes : :: std :: os :: raw :: c_uint , pub flags : :: std :: os :: raw :: c_uint , } # [ test ] fn bindgen_test_layout_ffi_cif ( ) { assert_eq ! ( :: std :: mem :: size_of :: < ffi_cif > ( ) , 32usize , concat ! ( "Size of: " , stringify ! ( ffi_cif ) ) ) ; assert_eq ! ( :: std :: mem :: align_of :: < ffi_cif > ( ) , 8usize , concat ! ( "Alignment of " , stringify ! ( ffi_cif ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const ffi_cif ) ) . abi as * const _ as usize } , 0usize , concat ! ( "Alignment of field: " , stringify ! ( ffi_cif ) , "::" , stringify ! ( abi ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const ffi_cif ) ) . nargs as * const _ as usize } , 4usize , concat ! ( "Alignment of field: " , stringify ! ( ffi_cif ) , "::" , stringify ! ( nargs ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const ffi_cif ) ) . arg_types as * const _ as usize } , 8usize , concat ! ( "Alignment of field: " , stringify ! ( ffi_cif ) , "::" , stringify ! ( arg_types ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const ffi_cif ) ) . rtype as * const _ as usize } , 16usize , concat ! ( "Alignment of field: " , stringify ! ( ffi_cif ) , "::" , stringify ! ( rtype ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const ffi_cif ) ) . bytes as * const _ as usize } , 24usize , concat ! ( "Alignment of field: " , stringify ! ( ffi_cif ) , "::" , stringify ! ( bytes ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const ffi_cif ) ) . flags as * const _ as usize } , 28usize , concat ! ( "Alignment of field: " , stringify ! ( ffi_cif ) , "::" , stringify ! ( flags ) ) ) ; } impl Default for ffi_cif { fn default ( ) -> Self { unsafe { :: std :: mem :: zeroed ( ) } } } extern "C" {
 pub fn ffi_prep_cif_core ( cif : * mut ffi_cif , abi : ffi_abi , isvariadic : :: std :: os :: raw :: c_uint , nfixedargs : :: std :: os :: raw :: c_uint , ntotalargs : :: std :: os :: raw :: c_uint , rtype : * mut ffi_type , atypes : * mut * mut ffi_type , ) -> ffi_status ; 
} # [ repr ( C ) ] # [ derive ( Copy , Clone ) ] pub union ffi_raw { pub sint : ffi_sarg , pub uint : ffi_arg , pub flt : f32 , pub data : [ :: std :: os :: raw :: c_char ; 8usize ] , pub ptr : * mut :: std :: os :: raw :: c_void , _bindgen_union_align : u64 , } # [ test ] fn bindgen_test_layout_ffi_raw ( ) { assert_eq ! ( :: std :: mem :: size_of :: < ffi_raw > ( ) , 8usize , concat ! ( "Size of: " , stringify ! ( ffi_raw ) ) ) ; assert_eq ! ( :: std :: mem :: align_of :: < ffi_raw > ( ) , 8usize , concat ! ( "Alignment of " , stringify ! ( ffi_raw ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const ffi_raw ) ) . sint as * const _ as usize } , 0usize , concat ! ( "Alignment of field: " , stringify ! ( ffi_raw ) , "::" , stringify ! ( sint ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const ffi_raw ) ) . uint as * const _ as usize } , 0usize , concat ! ( "Alignment of field: " , stringify ! ( ffi_raw ) , "::" , stringify ! ( uint ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const ffi_raw ) ) . flt as * const _ as usize } , 0usize , concat ! ( "Alignment of field: " , stringify ! ( ffi_raw ) , "::" , stringify ! ( flt ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const ffi_raw ) ) . data as * const _ as usize } , 0usize , concat ! ( "Alignment of field: " , stringify ! ( ffi_raw ) , "::" , stringify ! ( data ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const ffi_raw ) ) . ptr as * const _ as usize } , 0usize , concat ! ( "Alignment of field: " , stringify ! ( ffi_raw ) , "::" , stringify ! ( ptr ) ) ) ; } impl Default for ffi_raw { fn default ( ) -> Self { unsafe { :: std :: mem :: zeroed ( ) } } } pub type ffi_java_raw = ffi_raw ; extern "C" {
 pub fn ffi_raw_call ( cif : * mut ffi_cif , fn_ : :: std :: option :: Option < unsafe extern "C" fn ( ) > , rvalue : * mut :: std :: os :: raw :: c_void , avalue : * mut ffi_raw , ) ; 
} extern "C" {
 pub fn ffi_ptrarray_to_raw ( cif : * mut ffi_cif , args : * mut * mut :: std :: os :: raw :: c_void , raw : * mut ffi_raw , ) ; 
} extern "C" {
 pub fn ffi_raw_to_ptrarray ( cif : * mut ffi_cif , raw : * mut ffi_raw , args : * mut * mut :: std :: os :: raw :: c_void , ) ; 
} extern "C" {
 pub fn ffi_raw_size ( cif : * mut ffi_cif , ) -> usize ; 
} extern "C" {
 pub fn ffi_java_raw_call ( cif : * mut ffi_cif , fn_ : :: std :: option :: Option < unsafe extern "C" fn ( ) > , rvalue : * mut :: std :: os :: raw :: c_void , avalue : * mut ffi_java_raw , ) ; 
} extern "C" {
 pub fn ffi_java_ptrarray_to_raw ( cif : * mut ffi_cif , args : * mut * mut :: std :: os :: raw :: c_void , raw : * mut ffi_java_raw , ) ; 
} extern "C" {
 pub fn ffi_java_raw_to_ptrarray ( cif : * mut ffi_cif , raw : * mut ffi_java_raw , args : * mut * mut :: std :: os :: raw :: c_void , ) ; 
} extern "C" {
 pub fn ffi_java_raw_size ( cif : * mut ffi_cif , ) -> usize ; 
} # [ repr ( C ) ] # [ derive ( Debug , Copy , Clone ) ] pub struct ffi_closure { pub tramp : [ :: std :: os :: raw :: c_char ; 24usize ] , pub cif : * mut ffi_cif , pub fun : :: std :: option :: Option < unsafe extern "C" fn ( arg1 : * mut ffi_cif , arg2 : * mut :: std :: os :: raw :: c_void , arg3 : * mut * mut :: std :: os :: raw :: c_void , arg4 : * mut :: std :: os :: raw :: c_void ) > , pub user_data : * mut :: std :: os :: raw :: c_void , } # [ test ] fn bindgen_test_layout_ffi_closure ( ) { assert_eq ! ( :: std :: mem :: size_of :: < ffi_closure > ( ) , 48usize , concat ! ( "Size of: " , stringify ! ( ffi_closure ) ) ) ; assert_eq ! ( :: std :: mem :: align_of :: < ffi_closure > ( ) , 8usize , concat ! ( "Alignment of " , stringify ! ( ffi_closure ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const ffi_closure ) ) . tramp as * const _ as usize } , 0usize , concat ! ( "Alignment of field: " , stringify ! ( ffi_closure ) , "::" , stringify ! ( tramp ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const ffi_closure ) ) . cif as * const _ as usize } , 24usize , concat ! ( "Alignment of field: " , stringify ! ( ffi_closure ) , "::" , stringify ! ( cif ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const ffi_closure ) ) . fun as * const _ as usize } , 32usize , concat ! ( "Alignment of field: " , stringify ! ( ffi_closure ) , "::" , stringify ! ( fun ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const ffi_closure ) ) . user_data as * const _ as usize } , 40usize , concat ! ( "Alignment of field: " , stringify ! ( ffi_closure ) , "::" , stringify ! ( user_data ) ) ) ; } impl Default for ffi_closure { fn default ( ) -> Self { unsafe { :: std :: mem :: zeroed ( ) } } } extern "C" {
 pub fn ffi_closure_alloc ( size : usize , code : * mut * mut :: std :: os :: raw :: c_void , ) -> * mut :: std :: os :: raw :: c_void ; 
} extern "C" {
 pub fn ffi_closure_free ( arg1 : * mut :: std :: os :: raw :: c_void , ) ; 
} extern "C" {
 pub fn ffi_prep_closure ( arg1 : * mut ffi_closure , arg2 : * mut ffi_cif , fun : :: std :: option :: Option < unsafe extern "C" fn ( arg1 : * mut ffi_cif , arg2 : * mut :: std :: os :: raw :: c_void , arg3 : * mut * mut :: std :: os :: raw :: c_void , arg4 : * mut :: std :: os :: raw :: c_void ) > , user_data : * mut :: std :: os :: raw :: c_void , ) -> ffi_status ; 
} extern "C" {
 pub fn ffi_prep_closure_loc ( arg1 : * mut ffi_closure , arg2 : * mut ffi_cif , fun : :: std :: option :: Option < unsafe extern "C" fn ( arg1 : * mut ffi_cif , arg2 : * mut :: std :: os :: raw :: c_void , arg3 : * mut * mut :: std :: os :: raw :: c_void , arg4 : * mut :: std :: os :: raw :: c_void ) > , user_data : * mut :: std :: os :: raw :: c_void , codeloc : * mut :: std :: os :: raw :: c_void , ) -> ffi_status ; 
} # [ repr ( C ) ] # [ derive ( Debug , Copy , Clone ) ] pub struct ffi_raw_closure { pub tramp : [ :: std :: os :: raw :: c_char ; 24usize ] , pub cif : * mut ffi_cif , pub translate_args : :: std :: option :: Option < unsafe extern "C" fn ( arg1 : * mut ffi_cif , arg2 : * mut :: std :: os :: raw :: c_void , arg3 : * mut * mut :: std :: os :: raw :: c_void , arg4 : * mut :: std :: os :: raw :: c_void ) > , pub this_closure : * mut :: std :: os :: raw :: c_void , pub fun : :: std :: option :: Option < unsafe extern "C" fn ( arg1 : * mut ffi_cif , arg2 : * mut :: std :: os :: raw :: c_void , arg3 : * mut ffi_raw , arg4 : * mut :: std :: os :: raw :: c_void ) > , pub user_data : * mut :: std :: os :: raw :: c_void , } # [ test ] fn bindgen_test_layout_ffi_raw_closure ( ) { assert_eq ! ( :: std :: mem :: size_of :: < ffi_raw_closure > ( ) , 64usize , concat ! ( "Size of: " , stringify ! ( ffi_raw_closure ) ) ) ; assert_eq ! ( :: std :: mem :: align_of :: < ffi_raw_closure > ( ) , 8usize , concat ! ( "Alignment of " , stringify ! ( ffi_raw_closure ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const ffi_raw_closure ) ) . tramp as * const _ as usize } , 0usize , concat ! ( "Alignment of field: " , stringify ! ( ffi_raw_closure ) , "::" , stringify ! ( tramp ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const ffi_raw_closure ) ) . cif as * const _ as usize } , 24usize , concat ! ( "Alignment of field: " , stringify ! ( ffi_raw_closure ) , "::" , stringify ! ( cif ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const ffi_raw_closure ) ) . translate_args as * const _ as usize } , 32usize , concat ! ( "Alignment of field: " , stringify ! ( ffi_raw_closure ) , "::" , stringify ! ( translate_args ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const ffi_raw_closure ) ) . this_closure as * const _ as usize } , 40usize , concat ! ( "Alignment of field: " , stringify ! ( ffi_raw_closure ) , "::" , stringify ! ( this_closure ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const ffi_raw_closure ) ) . fun as * const _ as usize } , 48usize , concat ! ( "Alignment of field: " , stringify ! ( ffi_raw_closure ) , "::" , stringify ! ( fun ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const ffi_raw_closure ) ) . user_data as * const _ as usize } , 56usize , concat ! ( "Alignment of field: " , stringify ! ( ffi_raw_closure ) , "::" , stringify ! ( user_data ) ) ) ; } impl Default for ffi_raw_closure { fn default ( ) -> Self { unsafe { :: std :: mem :: zeroed ( ) } } } # [ repr ( C ) ] # [ derive ( Debug , Copy , Clone ) ] pub struct ffi_java_raw_closure { pub tramp : [ :: std :: os :: raw :: c_char ; 24usize ] , pub cif : * mut ffi_cif , pub translate_args : :: std :: option :: Option < unsafe extern "C" fn ( arg1 : * mut ffi_cif , arg2 : * mut :: std :: os :: raw :: c_void , arg3 : * mut * mut :: std :: os :: raw :: c_void , arg4 : * mut :: std :: os :: raw :: c_void ) > , pub this_closure : * mut :: std :: os :: raw :: c_void , pub fun : :: std :: option :: Option < unsafe extern "C" fn ( arg1 : * mut ffi_cif , arg2 : * mut :: std :: os :: raw :: c_void , arg3 : * mut ffi_java_raw , arg4 : * mut :: std :: os :: raw :: c_void ) > , pub user_data : * mut :: std :: os :: raw :: c_void , } # [ test ] fn bindgen_test_layout_ffi_java_raw_closure ( ) { assert_eq ! ( :: std :: mem :: size_of :: < ffi_java_raw_closure > ( ) , 64usize , concat ! ( "Size of: " , stringify ! ( ffi_java_raw_closure ) ) ) ; assert_eq ! ( :: std :: mem :: align_of :: < ffi_java_raw_closure > ( ) , 8usize , concat ! ( "Alignment of " , stringify ! ( ffi_java_raw_closure ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const ffi_java_raw_closure ) ) . tramp as * const _ as usize } , 0usize , concat ! ( "Alignment of field: " , stringify ! ( ffi_java_raw_closure ) , "::" , stringify ! ( tramp ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const ffi_java_raw_closure ) ) . cif as * const _ as usize } , 24usize , concat ! ( "Alignment of field: " , stringify ! ( ffi_java_raw_closure ) , "::" , stringify ! ( cif ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const ffi_java_raw_closure ) ) . translate_args as * const _ as usize } , 32usize , concat ! ( "Alignment of field: " , stringify ! ( ffi_java_raw_closure ) , "::" , stringify ! ( translate_args ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const ffi_java_raw_closure ) ) . this_closure as * const _ as usize } , 40usize , concat ! ( "Alignment of field: " , stringify ! ( ffi_java_raw_closure ) , "::" , stringify ! ( this_closure ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const ffi_java_raw_closure ) ) . fun as * const _ as usize } , 48usize , concat ! ( "Alignment of field: " , stringify ! ( ffi_java_raw_closure ) , "::" , stringify ! ( fun ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const ffi_java_raw_closure ) ) . user_data as * const _ as usize } , 56usize , concat ! ( "Alignment of field: " , stringify ! ( ffi_java_raw_closure ) , "::" , stringify ! ( user_data ) ) ) ; } impl Default for ffi_java_raw_closure { fn default ( ) -> Self { unsafe { :: std :: mem :: zeroed ( ) } } } extern "C" {
 pub fn ffi_prep_raw_closure ( arg1 : * mut ffi_raw_closure , cif : * mut ffi_cif , fun : :: std :: option :: Option < unsafe extern "C" fn ( arg1 : * mut ffi_cif , arg2 : * mut :: std :: os :: raw :: c_void , arg3 : * mut ffi_raw , arg4 : * mut :: std :: os :: raw :: c_void ) > , user_data : * mut :: std :: os :: raw :: c_void , ) -> ffi_status ; 
} extern "C" {
 pub fn ffi_prep_raw_closure_loc ( arg1 : * mut ffi_raw_closure , cif : * mut ffi_cif , fun : :: std :: option :: Option < unsafe extern "C" fn ( arg1 : * mut ffi_cif , arg2 : * mut :: std :: os :: raw :: c_void , arg3 : * mut ffi_raw , arg4 : * mut :: std :: os :: raw :: c_void ) > , user_data : * mut :: std :: os :: raw :: c_void , codeloc : * mut :: std :: os :: raw :: c_void , ) -> ffi_status ; 
} extern "C" {
 pub fn ffi_prep_java_raw_closure ( arg1 : * mut ffi_java_raw_closure , cif : * mut ffi_cif , fun : :: std :: option :: Option < unsafe extern "C" fn ( arg1 : * mut ffi_cif , arg2 : * mut :: std :: os :: raw :: c_void , arg3 : * mut ffi_java_raw , arg4 : * mut :: std :: os :: raw :: c_void ) > , user_data : * mut :: std :: os :: raw :: c_void , ) -> ffi_status ; 
} extern "C" {
 pub fn ffi_prep_java_raw_closure_loc ( arg1 : * mut ffi_java_raw_closure , cif : * mut ffi_cif , fun : :: std :: option :: Option < unsafe extern "C" fn ( arg1 : * mut ffi_cif , arg2 : * mut :: std :: os :: raw :: c_void , arg3 : * mut ffi_java_raw , arg4 : * mut :: std :: os :: raw :: c_void ) > , user_data : * mut :: std :: os :: raw :: c_void , codeloc : * mut :: std :: os :: raw :: c_void , ) -> ffi_status ; 
} extern "C" {
 pub fn ffi_prep_cif ( cif : * mut ffi_cif , abi : ffi_abi , nargs : :: std :: os :: raw :: c_uint , rtype : * mut ffi_type , atypes : * mut * mut ffi_type , ) -> ffi_status ; 
} extern "C" {
 pub fn ffi_prep_cif_var ( cif : * mut ffi_cif , abi : ffi_abi , nfixedargs : :: std :: os :: raw :: c_uint , ntotalargs : :: std :: os :: raw :: c_uint , rtype : * mut ffi_type , atypes : * mut * mut ffi_type , ) -> ffi_status ; 
} extern "C" {
 pub fn ffi_call ( cif : * mut ffi_cif , fn_ : :: std :: option :: Option < unsafe extern "C" fn ( ) > , rvalue : * mut :: std :: os :: raw :: c_void , avalue : * mut * mut :: std :: os :: raw :: c_void , ) ; 
} pub const ffi_type_enum_STRUCT : ffi_type_enum = 13 ; pub const ffi_type_enum_COMPLEX : ffi_type_enum = 15 ; pub type ffi_type_enum = :: std :: os :: raw :: c_uint ;